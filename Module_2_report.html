<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Template for Fractal Geometry Computational Lab Reports" />
  <link rel="stylesheet" href="https://latex.vercel.app/style.css" />
  <link 
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"
  />
  <script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
      }
    }
  </script>
  <title>Fractal Geometry Lab Report</title> 
</head>
<body id="top">




  <header>
    <h1>Module 2 Report</h1>
    <p class="author">
      Anthony Lenner <br />
      2/1/2025
    </p>
  </header>
  


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
         In this module, we learned how to draw some fractals using turtle graphics and loops. Namely, the Koch snowflake and the Dragon Curve. The code for the Koch snowflake and the dragon curve follows below.
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<pre><code class="language-python">

	#Koch snowflake	
		
	initializeTurtle()
	showturtle()
	
	# Define the blip_line function (Koch curve)
	def blip_line(length, order):
	    if order == 0:
	        forward(length)
	    else:
	        blip_line(length / 3, order - 1)
	        left(60)
	        blip_line(length / 3, order - 1)
	        right(120)
	        blip_line(length / 3, order - 1)
	        left(60)
	        blip_line(length / 3, order - 1)
	
	# Draw the Koch snowflake
	def koch_snowflake(length, order):
	    for _ in range(3):
	        blip_line(length, order)
	        right(120)
	
	# Set up the turtle
	jump(250, 500)
	face(0)
	color('blue')
	
	# Draw the snowflake
	length = 400
	order = 7
	koch_snowflake(length, order)
	
	show()	
		
	# Dragon Curve
	# Define the dragon curve function
def dragon_curve(order, length, turn_direction):
    # Base case: if order is 0, just move forward
    if order == 0:
        forward(length)
    else:
        # Calculate the new length for each recursive step
        new_length = length / (2 ** 0.5)

        # Recursively draw the dragon curve, turning right and left as needed
        dragon_curve(order - 1, new_length, 1)  # First segment
        right(turn_direction * 90)             # Turn by 90 degrees
        dragon_curve(order - 1, new_length, -1) # Second segment

	# Initialize the turtle for drawing
	initializeTurtle(initial_window_size=(1000, 8000), mode='auto')

	# Move the turtle to a starting position
	jump(400, 400)
	face(0)             # Set starting direction
	color('purple')     # Choose a color
	
	# Set up initial order and length
	order = 0          # Complexity level
	length = 300        # Initial length of each segment
	
	# Draw different orders of the dragon curve
	
	for order in range(14):
	  dragon_curve(order, length, 1)
	  penup()
	  jump(400, 500*(2+order))
	  pendown()
	  face(0)
	
	# Show the final drawing
	show()

	</code></pre>






      </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
          The first thing we learned in the module was how to code Brownian motion. The code is quite simple, it consists of a loop that creates a line and then changes the angle randomly, so that the turtle takes a random walk.
	  The next thing we learned was the fractal drawing process. For the Koch's snowflake, we first defined a blip line function, which is the part of the fractal that repeats itself. To do that, we use an if statement. It is an iterative process that works a lot like mathematical induction. Note that the arguments of this function are the length of the line and the order (how many times it repeats itself). We define the base case, where the order is 0, as a straight line. Then, if the order is some number n>0, we draw a blip line of order n-1, turn 60 degrees left, draw another blip line of order n-1, turn 120 degrees right, draw the last blip line of order n-1. Now that we have this function, we just need a koch_snowflake function of the length and order to glue three blip lines together side to side, forming a triangle of blip lines. As n approaches infinity, we get the fractal. Of course, we can't render an infinite order. In fact, my laptop is only able to render up to order 7. Nevertheless, the image is impressive.  
        </p>




        <figure>
          <img
            src="https://anthonylenner.github.io/labreports/images/koch_snowflake_order_7.png"
            alt="Koch Snowflake of order 7"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
             Koch Snowflake of order 7.
          </figcaption>
        </figure>


	      <p>
         The dragon curve follows a similar process. We create a dragon_curve function that draws a line if order=0 or draws two dragon curves of order n-1 glued together at an angle of 90 degrees if order=n>o. I have extended the code to show the iterative process in action; the first ten iterations of the curve. As with the snowflake, the fractal forms when we let n approach infinity. 	      
	      </p>

	      <figure>
          <img
            src="https://anthonylenner.github.io/labreports/images/dragon_curve_iterated.png"
            alt="Dragon Curve"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            The Dragon Curve, from the first to the tenth iteration.
          </figcaption>
        </figure>



      </section>



      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
          In this sample conclusion, we highlight how the iterative approach to generating fractals reveals the vast complexity inherent in seemingly simple equations. Through our Python implementation, we observed that small parameter changes can produce markedly different fractal patterns, underscoring the Mandelbrot set's boundless intricacy. Our visualizations not only confirm the self-similarity and infinite resolution of the set, but also underscore the crucial role of computational optimizations in making high-resolution explorations feasible. Ultimately, this lab demonstrates that fractal geometry, far from being mere mathematical curiosities, provides deep insights into pattern formation and complexity in both pure mathematics and broader scientific contexts. 
        </p>
      </section>

     
     
     
   
     
     
     
  </main>

  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
